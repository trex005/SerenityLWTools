The current date/time throughout this app is based on UTC-2
The only place that I see that referenced is /componants/date-range-selector.tsx in the getUtcMinus2Date function.

Find other places this is handled and then build a unified function that they all use.


--------------
Do not start any modifications to the code at this point.
If you need futher clarification, ask me one question at a time until we have this fully designed.
When it is fully designed, please give me the steps you will need to take in order to write and implement it.

I would like to add a Reminder feature to this progam.
Each Operation should have an optional plain text field called "Reminder"

Add a reminder tab which will default to the current day but have a date selector to change the day.

In that tab, have an editable textarea with the selected days reminders.  The text area should start with "Reset in X minutes!" followed by two newlines, and then "Reminders:" followed by a newline and then a list of the reminders for that day, each prefixed with "• "

The reminders should be listed in the same order as the operations are listed for that day.

-------------------
The debug information is correct e.g. the following is what it shows the day before Marshal, however, the previous day reminders are not listed in the textarea.

Debug: 42 total events, 3 with remindOnPreviousDay, 1 with reminders
Tomorrow (Wednesday): 1 matching events
-------------------
Do not start any modifications to the code at this point.
If you need futher clarification, ask me one question at a time until we have this fully designed.
When it is fully designed, please give me the steps you will need to take in order to write and implement it.

There is a bug where schedules are being split at calendar week boundaries. For example, a Friday–Wednesday block becomes Sunday–Wednesday plus Friday–Saturday, instead of a continuous run.

The fix is to base all calculations on integer day offsets from the start_date, not on calendar weeks.

Rule: Treat everything as a repeating cycle of periods, where a period is a number of days (1 for daily, 7 for weekly). Each cycle has on_periods and off_periods. A day is active if it falls in the on block, and if applicable, also matches an allowed weekday filter.

Pseudocode:

d = floor((target_date - start_date) / 1 day)
if d < 0: return false

cycle_days = period_days * (on_periods + off_periods)
pos = d % cycle_days
in_on_block = pos < period_days * on_periods

if has_weekday_filter:
    return in_on_block and (weekday(target_date) in allowed_weekdays)
else:
    return in_on_block


Examples:

Every 3rd day: period_days=1, on=1, off=2

5 weeks on, 2 weeks off: period_days=7, on=5, off=2

Mon/Wed/Fri on a 3-weeks-on, 1-week-off cycle: period_days=7, on=3, off=1, weekdays={Mon,Wed,Fri}
------------

We do not need to keep the current recurrence data structure, but we will need some way to convert our current data.

"interval" and "type" are a fallback if "pattern" doesn't exist.
in this case:
if type == weekly: period = 7
if type == daily: period = 1
on_periods = 1
off_periods = interval - on_periods

if "pattern" does exist
period = 7
on_periods = onWeeks
off_periods = offWeeks

------------------

Here is an example:

"pattern": {
    "onWeeks": 2,
    "offWeeks": 1,
    "phaseStartDate": "2025-02-24T05:00:00.000Z"
}

in this case:
period = 7
on_periods = 2
off_periods = 1

I am uncertain why there are sometimes both a phaseStartDate, and a startDate outside of the pattern. If there is a startDate, use that, if not, fallback to phaseStartDate
-------------------------
We will also need to adjust the UI to work with the new structure.
The edit event form should include:

Type: (Days/Weeks)
[Selected Type] on:
[Selected Type] off:
Days of the week:
Start Date:
-------------------------
The labels have become a bit too confusing. Here is some Pseudocode for a way to simplify them. Can you please read it and, before implementing it, describe to me what it does so I know we are on the same page?

function format_label(period_days, on_periods, off_periods, weekdays, start_date, show_start_date):

    all_days = {Sun, Mon, Tue, Wed, Thu, Fri, Sat}
    all_weekdays_selected = (weekdays == all_days)

    # Step 1: base phrase from periods
    if on_periods == 1 and off_periods > 0:
        unit = "days" if period_days == 1 else "weeks" if period_days == 7 else period_days + "-day periods"
        label = "Every " + (off_periods + 1) + " " + unit
    else:
        if period_days == 1:
            label = on_periods + " days on, " + off_periods + " off"
        else if period_days == 7:
            label = on_periods + " weeks on, " + off_periods + " off"
        else:
            label = on_periods + " periods on, " + off_periods + " off (" + period_days + "-day period)"

    # Step 2: add weekday filter if not all selected
    if not all_weekdays_selected and not weekdays.is_empty():
        label = label + " on " + format_weekdays_compact(weekdays)

    # Step 3: optionally add start date
    if show_start_date:
        label = label + ", starting " + format_date(start_date)

    return label


function format_weekdays_compact(weekdays_set):
    # Collapse consecutive weekdays into ranges, with wraparound allowed
    names = [Sun, Mon, Tue, Wed, Thu, Fri, Sat]      # index 0..6
    selected = [ (names[i] in weekdays_set) for i in 0..6 ]

    # If none, return empty
    if not any(selected):
        return ""

    ranges = []   # list of (start_index, end_index) inclusive
    visited = [false]*7

    for i in 0..6:
        prev = (i + 6) % 7
        if selected[i] and not selected[prev]:
            # start of a run
            j = i
            while selected[j]:
                visited[j] = true
                j = (j + 1) % 7
                if j == i: break
            end = (j + 6) % 7
            ranges.append( (i, end) )

    # Convert ranges to text
    parts = []
    for (s, e) in ranges:
        if s == e:
            parts.append( names[s] )
        else:
            parts.append( names[s] + " to " + names[e] )

    return join(parts, ", ")

---------------------
Sometimes it is displaying an old days of the week block which I thought was deleted. Can you completely remove that?
----------------------
When creating a new event, I wanted you to default the day to today. However, when editing an old event, if it does not have a start date, please use our 2025-01-05 default
--------------------

The file /public/server_birthday.html is a calculator that gives various information about a server based on the day it started. Most things seem to be working correctly however the Loot Goblin status is not properly calculating.

Test:
Currently, (2025-09-12) The status should be Active for birthdays 2024-10-02 through 2024-10-08 and inactive for birthdays 2024-10-09 through 2024-10-15
-----------------------
To the left of the birthday field, allow a user to optionally select a known server and automatically populate its birthday.

Here is my list of known server birthdays so Far
972 - 2024-10-04
976 - 2024-10-05
977-981 - 2024-10-06
982-986 - 2024-10-07
987-989 - 2024-10-08
990-993 - 2024-10-09
994-996 - 2024-10-10
997-999 - 2024-10-11
1000-1001 - 2024-10-12

------------------------
Do not start any modifications to the code at this point.
If you need futher clarification, ask me one question at a time until we have this fully designed.
When it is fully designed, please give me the steps you will need to take in order to write and implement it.

In this app, there are something called tips. Currently those tips can be text, html or an image URL. Is there a way, without using frames or iframes that I can embed calculators, like server_birthday into the tips?
-------------------------
Do not start any modifications to the code until you are 95% certain you understand what the user is looking for. Instead, ask one clarifying question at a time until you are certain.
If the changes are complex, present the user with a numbered list of the implementation steps for review and feedback.

Add a new feature to events where a optional end date can be specified.
• The span between start date and end date is inclusive.
• Update all schedule related functions
• update the event card used in the admin interface to allow the user to set the end date.
----------------------
please always use npm at the following path: "/c/Program Files/nodejs/npm"
----------------------
**tools: Config rewrite** 
Do not start any modifications to the code at this point.
If you need futher clarification, ask me one question at a time until we have this fully designed.
When it is fully designed, please give me the steps you will need to take in order to write and implement it.

I would like to update how data storage works\
• There is no need to maintain backward compatibility with the current config file, config-init.json
• Configuration files should be determined first by the URL variable tag, and if that does not exist, buy the domain.
   • We will need some type of root config that maps the domain to a tag
• Configuration files should be stored in the final project in /conf/{tag}/ This means in our development environment, they should be in public/conf/{tag}/

• Configuration files should be split into:
config.json
events.json
events_archive.json
tips.json

• Local Storage should also be segrigated by tag
• All of this must continue to use only client side processing. Meaning that the domain and URL parameters need to be parsed by client side javascript.
------------------
you can analyse config-init.json here:
public/config-init.json

All config management should be contained in
hooks/use-config-data.ts
hooks/config-fetcher.ts

I'm not certain if any of this code is no longer in use. That would be a good thing to check before trying to update it.
-------------------
Output plan from Codex:
After a second look, I’m confident the changes can stay confined to the shared config/storage layer while keeping the rest of the app’s API untouched.

Config & Tag Resolution

Inspect lib/config-fetcher.ts, hooks/use-config-data.ts, and related callers to confirm the current public interfaces and spot any unused helpers we can retire.
Implement a resolver that loads public/conf/default.json, sanitizes and selects the active tag (query param → domain → fallback), and computes the file paths under public/conf/{tag}/.
Extend the fetch logic so config.json, events.json, events_archive.json, and tips.json are fetched per tag, each returning its data plus the required updated timestamp; treat missing files as empty payloads but still emit an updated timestamp.
Data Shape & Fallbacks

Assemble the retrieved pieces into the exact structure the existing hooks expect (active and archived events merged when necessary), while dropping the legacy config-init fallback so the transition is clean.
Scoped Storage

Add a centralized helper for localStorage namespacing that prefixes/suffixes keys with the active tag, and update the storage plumbing inside the shared hooks/utilities so every persisted value (events store, tips store, admin flags, preferences, AWS creds, etc.) is isolated per tag.
Verification

Seed example configs beneath public/conf/{tag}/ and exercise tag resolution (query parameter, domain match, default fallback) to ensure data loads and persists correctly.
Spot-check localStorage contents to confirm segregation by tag, and run lint/build to ensure the refactor doesn’t introduce regressions.
----------------------
Please make the export function in the command center export in this new format. Allow the user to choose which of the config files to export. If simple, allow them to choose "all" and have it download a zip with all of them.

The eport file name should be:
{type}_{tag}_timestamp.{filetype}
e.g.
events_serenity_{timestamp}.json
or
all_serenity_{timestamp}.zip
--------------
**tools: Config inheretence** 
Do not start any modifications to the code at this point.
If you need futher clarification, ask me one question at a time until we have this fully designed.
When it is fully designed, please give me the steps you will need to take in order to write and implement it.

in conf/{tag}/conf.json add an attribute for a parent tag. This should be recursive with a sanity check.

Both the json files and the localStorage should work in a similar way, merging events and tips based on id

Loading data:
    If parent is set, load it's scope
    do this recursively
Reading Data
    read field from child if exists
    if not, read field from parent
    do this recursively
Saving/Exporting Data:
    parent fields should never be overwitten, just overridden with child fields
    if field is different from parent tag, save
    if field is same as parent, remove child if exists


Notes:
• json exports will need to be smart about how they store events that do not have the same archived value in parent/child
• fields should act like a deep merge, with the bottom level key being overwritten
parent:
{
  "events": [
    {
      "id": "ev-3",
      "title": "Zombie Siege",
      "archived": false,
      "recurrence": {
        "type": "days",
        "onPeriods": 1,
        "offPeriods": 2,
        "daysOfWeek": ["monday", "wednesday", "friday"],
        "startDate": "2025-09-29T04:00:00.000Z"
      },
      "remindTomorrow": true,
      "includeInExport": {
        "monday": true,
        "tuesday": true,
        "wednesday": true,
        "thursday": true,
        "friday": true,
        "saturday": true,
        "sunday": true
      }
    }
  ]
}
child:
{
    "events": [
    {
      "id": "ev-3",
      "archived": false,
      "recurrence": {
        "daysOfWeek": ["wednesday"]
      },
      "includeInExport": {
        "wednesday": false
      }
    }
  ]
}
becomes:
{
  "events": [
    {
      "id": "ev-3",
      "title": "Zombie Siege",
      "archived": false,
      "recurrence": {
        "type": "days",
        "onPeriods": 1,
        "offPeriods": 2,
        "daysOfWeek": ["wednesday"],
        "startDate": "2025-09-29T04:00:00.000Z"
      },
      "remindTomorrow": true,
      "includeInExport": {
        "monday": true,
        "tuesday": true,
        "wednesday": false,
        "thursday": true,
        "friday": true,
        "saturday": true,
        "sunday": true
      }
    }
  ]
}

-------------
Codex Output:
Here’s the plan I’d follow to implement the inheritance flow:

Extend Tag Metadata

Add a parent field to per-tag config.json (public/conf/{tag}/config.json and typed interfaces).
Update the config loader to read this field and build a parent chain with cycle detection and missing-parent fallbacks.
Resolve Config Hierarchy

Enhance fetchConfig to load parent bundles recursively (reusing caches), building an ordered ancestry list (top → child).
Introduce utility helpers to normalize/merge per-tag data and expose both raw layers and the resolved composite.
Deep Merge Events/Tips

Implement ID-based merge logic for events and tips:
• Combine parent and child arrays by id, deep-merging objects recursively.
• Overwrite primitive fields and arrays entirely; merge nested objects by key.
• Preserve parent entries untouched when no child override exists.
Ensure special handling for archived, includeInExport, variations, etc., matches the deep-merge rules.
LocalStorage Composition

Adjust scoped stores (use-events, use-tips, admin state) to hydrate using the merged view while retaining the ability to store only child-specific overrides.
When persisting changes, write back only the delta against the parent chain.
Writers & Exports

Update mutation paths (add/update/delete events/tips) so they compute child deltas before saving.
Revise the admin export workflow to emit separate files containing just the child-level overrides, and ensure ZIP/export filenames remain unchanged.
Sanity Checks & Error Messaging

Guard against circular parents and missing tags as specified, surfacing console warnings/toasts as needed when falling back to “top-level” behavior.
Add diagnostics for conflicting IDs (e.g., mismatched types) during merge.
Manual Validation

Create sample parent/child tag configs to test overrides (archived flag differences, partial object overrides, array replacement).
Verify localStorage segregation still works per tag, with inherited data loading correctly and edits affecting only child overrides.
Re-run lint/build once the dependency issue is addressed.
----------------
codex Output:
Here’s the reviewed design and the concrete implementation plan.

Assumptions

Tags remain normalized (current behavior). If you want case-sensitive tags, we’ll adjust separately.
Parent chain uses only JSON files; do not consult parent tags’ localStorage.
Consumers (UI/components) stay unaware of inheritance; all logic is confined to config/storage utilities.
Merge Semantics

Per-id deep merge across ancestry: parent → … → child.
Bottom-level rule: primitives (string/number/boolean), null, and arrays are replaced wholesale when present in child; objects merge by key, recursing until bottom-level.
Arrays (e.g., recurrence.daysOfWeek) replace entirely when present in child.
Object maps (e.g., includeInExport, variations, dateOverrides, order) merge by key, with child keys overwriting or removing keys explicitly set to null if we support null-removal later.
Inheritance Rules

Each conf/{tag}/config.json may include "parent": "someTag".
Build ancestry list top→child by following parent pointers:
Missing parent tag → stop and treat current tag as top.
Cycle detected (revisiting a tag) → stop at first repeat; treat that ancestor as top.
Also enforce a max depth (e.g., 16) as a sanity guard.
Load all JSON for each ancestor: config.json (optional), events.json, events_archive.json, tips.json.
Compose data by:
Start with parent’s arrays (active + archived for events, tips).
For each descendant layer, apply per-id deep merges on top of accumulated state.
Apply deletions (tombstones) from the layer, which remove the item from the composed view (see below).
Archived flag follows bottom-level overwrite: if child sets archived, it overrides inherited value; if not set, inherited value stands.
Deleted Tombstones

Deleted in child fully masks parent: item is removed from the final composed view.
Represent as minimal tombstones in the child exports:
Events: write { "id": "...", "deleted": true } into conf/{tag}/events.json (even if parent’s item is archived).
Tips: write { "id": "...", "deleted": true } into conf/{tag}/tips.json.
The loader hides deleted items entirely from the app (UI never sees them).
Archived Handling

During merge, archived is just a boolean field obeying the bottom-level rule.
“Smart” child exports:
If child changes archived, the child override for that id goes into:
events.json if effective archived=false
events_archive.json if effective archived=true
If child does not mention archived but overrides other fields, place its override in the file matching the inherited archived state (from composed parent).
Deleted tombstones always go to events.json (per above), regardless of parent archived state.
Data Flow

Loading:
Resolve tag.
Build ancestry chain (with loop/missing-parent guards).
Fetch parent→child JSON files for each tag.
Compose:
Build maps keyed by id for events (active+archived) and tips for each layer.
Apply deep merges; arrays replace; objects merge; primitives replace.
Apply per-layer deletions last for that layer (masking any prior parent/ancestor).
Return merged arrays: one Events array (with archived flag per item), and Tips array.
Reading:
Libraries expose only the composed view; downstream code reads merged values transparently.
LocalStorage:
Continue using per-tag scoped storage.
Store only child-layer overrides (the “delta”) for the current tag, not full copies:
Per-id override objects with only differing bottom-level fields vs the composed parent.
Arrays stored only when truly different (full replacement).
No parent localStorage consulted during merge (only JSON chain).
Saving/Mutations:
Compute diff of the new item vs the composed parent result:
If different → write/update the child override with only minimal fields that differ.
If same as parent → remove any existing child override for those fields; if empty override remains, remove the whole child override for that id.
If “delete” → write { id, deleted: true } tombstone in the child data; remove any existing child overrides for that id.
For events, choose events.json vs events_archive.json file placement for overrides based on the effective archived value in the child; tombstones still go to events.json.
Exporting:
Export per-file overrides (child-only deltas and tombstones), not the composed full view.
“All” export bundles child deltas for config.json (including "parent": "..." when present), events.json, events_archive.json, tips.json into a zip.
Edge Cases & Diagnostics

Conflicting type shapes on a bottom-level key → child wins (replace); log a console warn for diagnostics.
Parent missing id: child stands alone (merge just inserts the child item).
Guard logs for cycles and missing parents; proceed per rules above.
Implementation Steps

Types & Config

Extend tag config schema to include optional "parent": string.
Add ancestry resolution with cycle/missing-parent guards (visited set + max depth).
Loader Enhancements

In lib/config-fetcher, add functions to:
Load chain of tag bundles (root→leaf).
Merge per layer with ID-indexed deep-merge for events/tips.
Apply deletions (filter out from merged view).
Return: composed events (single array with archived flag), composed tips, plus side-channel metadata for export/diffing.
Deep Merge Utility

Implement mergeById(parent[], child[], opts) with:
Key extractor (id).
Deep object merge (objects merge; arrays replace; primitives replace).
Preserve archived rules and map-like keys (includeInExport, variations, dateOverrides, order).
LocalStorage Delta Layer

Introduce “child override cache” structure per tag in scoped storage:
events_overrides map by id: object with only differing leaf fields.
events_tombstones set of ids (or embed {id, deleted: true} in overrides array).
tips_overrides, tips_tombstones similarly.
Apply local overrides as the final layer on top of JSON ancestry during composition.
Writers update only the overrides/tombstones; do not duplicate parent state.
Save & Export Plumbing

Add diffing helpers: computeDelta(mergedParentItem, childEditedItem) → minimal override.
On delete: write tombstone and remove any existing overrides for that id.
Update admin export to generate per-file child deltas + tombstones following archived-placement rules and filenames you specified.
Validation

Create small parent/child fixtures demonstrating:
Deep object merges (includeInExport and variations per-key).
Array replacement (daysOfWeek).
Archived flips and placement logic.
Deletions masking parents; tips deletions.
Verify UI sees composed view only; ensure toggling archived and delete behaves as expected.
Verify exports contain only child deltas/tombstones.
If you’re happy with this design, I’ll proceed to implement it in the central config/storage libraries and update the admin export accordingly.

---------
Getting in line has a 30 min cooldown so assuming there is no one else in line
00:00 - Get in line/Get title/Co-op
00:30 - Get in line/Get title again (still have co-op)
01:00 - Could get in line again, but don't have co-op

Add 10 min line in front of you:
00:00 - Get in line
00:10 - Get title/co-op
00:30 - Get in line/title
01:00 - Get in line (Still have co-op for 10 min)
01:05 - hopefully have title by now!
--------------------
I am still having problems:

Test 1:
• go to http://localhost:3000/?tag=main (well populated tag with no parent)
  • content loads fine
• swith to admin mode
  • No content visible
  • exports empty config stubs
• Use "Restore Default Data" function
  • Expected data is now visible
  • exports contain data
• Refresh
  • No content visible
  • exports empty config stubs


Test 2:
• go to http://localhost:3000/?tag=996 (tag with minor changes and parent set to "main")
  • content loads fine
• swith to admin mode
  • No content visible
  • exports DO contain tag data
• Use "Restore Default Data" function
  • Expected data is now visible
  • exports ONLY contain empty stubs
• Refresh
  • No content visible
  • exports DO contain tag data

So it seems that when going into admin mode:
A tag with a parent does load that tags data, but is not able to access any of the parent's data.
A tag with no parent does NOT load that tag's data

It is possible that there is some counfounding problem, such as the data from the main tag having some sort of error on inport, but I do not see anything in the console log that would indicate that. The console does have 404 errors from all the config files it looks for that do not exist.
-----------

tag:main (no parent) in admin:
• Expected Data visible
• Data exports
• On reload, all changes are lost

tag: 996 (parent:main) in admin:
• Parent data visible
• Exports only stubs
• On reload, all changes are lost

The one consisten thing in every single test is that no event/tip data has loaded from localstorage after reload. This seems like it could be due to it never actually being saved to localstorage or perhapse being saved in a different way than is being accessed.
------------

**Tag data not persisting**
Changes made to events and tips in the admin interface are not persisting on reload.
I'm not sure if this is because 
------------------